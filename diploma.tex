% !TeX encoding = windows-1251
\documentclass[a4paper,12pt]{diplom}
\inputencoding{cp1251} % Кодировка вашего файла
\usepackage{paratype} % Шрифты (можно отключить, если дает ошибку)
%% Немного увеличим шрифт в математическом режиме, чтобы соответствовать размерам Paratype-шрифтов
\DeclareMathSizes{12}{13.4}{11}{10}

\usepackage[left=3cm,right=2cm,top=2cm,bottom=2cm]{geometry} % Размеры полей
\usepackage[onehalfspacing]{setspace} % Полуторный интервал
%\renewcommand{\baselinestretch}{1.25} % Полуторный интервал
\usepackage{indentfirst} % Абзацный отступ в начале разделов
\setlength{\parindent}{1.25cm} % Величина абзацного отступа

\usepackage[pdftex]{graphicx} % Для вставки изображений
\usepackage{array} % Для таблиц
\usepackage{booktabs} % Для красивых таблиц 
\usepackage{tikz} % Рисунки с помощью TikZ
\usepackage[linesnumbered,lined,ruled]{algorithm2e} % Для оформления псевдокода
%\usepackage{algorithm} % Альтернатива оформления псевдокода
%\usepackage{algpseudocode} % Альтернатива оформления псевдокода
\usepackage{listings} % Оформление листингов программ
\usepackage{icomma} % Удаляем тонкий пробел после запятой в мат. режиме

% Если на нумерованную формулу нет ссылки в тексте,
\mathtoolsset{showonlyrefs} % то она становится ненумерованной

% microtype улучшает распределение символов в строке
\usepackage{microtype}  % Можно отключить, если возникают ошибки компиляции

% Формируем PDF с полноценными перекрестными ссылками
\usepackage[unicode, pdfborder={0 0 0}, pdfstartview=FitV]{hyperref}

% Часто используемые макросы
\newcommand{\N}{\mathbb{N}}  % Множество натуральных чисел
\newcommand{\Z}{\mathbb{Z}}  % Множество целых чисел
\newcommand{\R}{\mathbb{R}}  % Множество действительных чисел
\DeclareMathOperator{\sgn}{sgn} % Знак числа
\DeclareMathOperator{\M}{\mathsf{M}} % Матожидание
\newcommand{\from}{\colon} % Двоеточие в определении функции. Пример: $f \from \R \to \N$.
% Заменяем англоязычные обозначения на русские
\renewcommand{\le}{\leqslant}
\renewcommand{\leq}{\leqslant}
\renewcommand{\ge}{\geqslant}
\renewcommand{\geq}{\geqslant}
\renewcommand{\emptyset}{\varnothing}
\renewcommand{\epsilon}{\varepsilon}

%%%%%%%%%%%%%%%%%%%%%%%%%%
% Конец преамбулы
%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

% Содержимое титульного листа

%\LetterHead{Минобр...}
\Kafedra{Кафедра компьютерных сетей}

% Зав. кафедрой
\ZavKaf{Заведующий кафедрой,\\ д.\,ф.-м.\,н., профессор}{С.\,Д.~Глызин}
% Если это курсовая работа и виза зав. каф. не нужна, раскомментируйте следующую строку
%\Kursovaya

% Вид работы: Курсовая работа, Выпускная квалификационная работа, 
\DocumentType{\large Выпускная квалификационная работа}

% Название дипломной работы
%\Title{\begin{Large}\bfseries Название дипломной работы\\ не помещающееся в одну строку\end{Large}}
\Title{\Large\bfseries Разработка сервиса\\ централизованного управления паролями}

% Направление подготовки
\Napr{по направлению\\ 01.03.02 Прикладная математика и информатика}

% Руководитель
\Chief{Научный руководитель\\ к.\,ф.-м.\,н., доцент}{С.\,В.~Алешин}

% Автор
\Author{Студент группы ИВТ-41БО}{Н.\,С.~Батогов}

%\City{Ярославль}
%\Year{2022}


% Создаем титульный лист
\maketitle

\chapter*{Реферат}

Объем \total{page} с., \total{chapternum} гл., \total{fignum} рис.,
\total{tablenum} табл., \total{bibnum} источников, \total{appnum} прил.

\medskip

Ключевые слова: \textbf{управление паролями, пароль, генерирование пароля, хранение паролей, безопасность компании, кибербезопасность, защита данных, одностраничное приложение.}

\medskip

Объект исследования - централизованное корпоративное управление паролями.

Цель работы - создание сервиса для удобного, безопасного и централизованного управления паролями в компании.

В результате работы был спроектирован, реализован и протестирован сервис, который позволяет решить данную задачу.

Область применения - небольшая компания, которой нужно удобно организовать пароли для почты, сайтов, серверов, карт и других ресурсов.

% Содержание
\tableofcontents[Содержание]

% Пример ненумерованной главы
\chapternonum{Введение}
В настоящее время разработка веб-приложений является одной из самых перспективных отраслей современного IT. Веб-приложение - это полноценная программа, которую пользователи использует через браузер. Именно поэтому данный вид разработки получил такой большой интерес в последнее время, ведь браузеры есть у каждого. Многие предприниматели переносят свой бизнес в диджитал сферу и выбирают для этого именно веб-приложение.
Почти любое веб-приложение можно реализовать в короткие сроки по сравнению с обычным десктопным приложением, а так же любое такое приложение будет кроссплатформенным, ведь оно работает только в браузере клиента. С помощью такого метода программирования можно с легкостью реализовывать даже самые сложные бизнес-процессы и задумки.
В рамках данной работы мы будем использовать термин "сервис".


Современный Интернет невозможно представить без паролей, систем шифрования, аутентификации и авторизации пользователей.
Одна из самых важных частей каждого человека в сети - это его пароли, но, к сожалению, достаточно много людей не хотят уделять внимание их безопасности. Когда же дело касается безопасности корпоративных паролей,то разговор идет не только о надежной защите данных конкретного пользователя, но и о сохраннении имиджа и репутации всей компании. 
Одновременно с этим, многие компании в своей работе используют незащищенные и неудобные инструменты управления и хранения паролей. Не стоит забывать, что от правильной тактики хранения паролей зависит и уровень защиты от кибератак. Для компании критически важно, чтобы у администратора системы хранения паролей было понимание того, у кого есть тот или иной доступ к информации.
Многие используют слишком примитивные способы хранения паролей, например текстовые файлы на рабочем столе компьютера, письма или документы в облаке. Для того, чтобы избежать таких способов и грамотно управлять корпоративными паролями требуется специальный инструмент, заточенный под конкретные нужды компании. Такие инструменты называют менеджерами паролей.
В большинстве случаев, компании предпочитают рациональный, надежный и удобный подход к внутреннему приложению собственной команды. Следовательно, наилучшим способом реализации сервиса для централизированного управления паролями можно считать именно веб-приложение.
%vuet
Объектом исследования является централизованное корпоративное управление паролями.

Предметом исследования является сервис для безопасного, централизованного и удобного управления паролями.

Целью выпускной квалификационной работы является создание сервиса для удобного, безопасного и централизованного управления паролями в компании. Данный сервис позволит небольшим компаниям грамотно работать со своими паролями, а так же не переживать за безопасность их хранения.

Для достижения этой цели необходимо решить следующие задачи:
\begin{itemize}
	\item произвести аудит существующих сервисов для хранения паролей(менеджеров паролей)
	\item создать клиентскую часть(интерфейс) сервиса
	\item создать серверную часть сервиса
\end{itemize}
???

\chapter[Разработка сервиса]{Разработка сервиса}

\section{Архитектура сервиса}
Приложение написано в стиле SPA(Single page application). SPA - это одностраничное приложение, которое работает в браузере и не требует перезагрузки за счет динамического обновления контента с помощью технологии AJAX(Asynchronous Javascript and XML). При использовании AJAX мы получаем много приемуществ, например: 
\begin{enumerate}[label=\arabic{enumi})]
	\item активное взаимодействие пользователя с веб-страницей(интерактивность)
	\item плавная работа с приложением
	\item удобное использование всей страницы
	\item уменьшение трафика пользователя
	\item снижение нагрузки на сервер
	\item положительное влияние на пользовательский опыт
\end{enumerate}

На рис.~\ref{fig:1} можно посмотреть отличия классического сайта от приложения в стиле SPA.
\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.7\textwidth]{img/diffBetweenSPA.jpg}
	\caption{Отличия сайта от SPA}
	\label{fig:1} % Метка для ссылки в тексте
\end{figure}
В нашем сервисе данные передаются через формат JSON.

Для написания в данном стиле программисту желательно использовать специальную библиотеку для написания клиентского кода. Самые полюбившиеся сообществом JavaScript-библиотеки для такой задачи на рынке сейчас представлены на рис.~\ref{fig:2}.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.7\textwidth]{img/framworks.jpg}
	\caption{библиотеки JavaScript с наибольшим количеством звезд GitHub}
	\label{fig:2} % Метка для ссылки в тексте
\end{figure}

Таким образом, все вышеперечисленные достоинства одностраничного приложения делают его оптимальным выбором для реализации сервиса.

Взаимодействие между клиентом и сервером происходит в классическом REST(Representational state transfer) API стиле через протокол HTTP. REST API - это способ взаимодействия клиента с сервером при котором клиент отправляет запросы на сервер, тот в свою очередь их обрабатывает и посылает ответ. API в данном случае выступает посредником между ними.
На рис.~\ref{fig:3}. представлена схема работы REST API.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.9\textwidth]{img/rest.png}
	\caption{схема работы REST API}
	\label{fig:3} % Метка для ссылки в тексте
\end{figure}

У HTTP есть свои особенности - ресурсы и HTTP-глаголы. Разобраться с данными терминами лучше всего на примере. Предположим что у нас есть ссылка http://test.ru/folders/1. Ее можно разбить на 3 составляющих: 
\begin{enumerate}[label=\arabic{enumi})]
	\item http:// - протокол для передачи данных
	\item test.ru/ - сервер
	\item folders/1 - путь к ресурсу, в данном случае первая папка
\end{enumerate}

Ресурс мы можем ассоциировать с каким-то объектом. Для понимания как именно нам нужно работать с этим объектом нам нужны HTTP-глаголы. HTTP-глаголы - это элемент протокола HTTP, который используется в каждом запросе, чтобы указать, какое действие нужно выполнить над данным ресурсом.[2]
Выделяют 5 основных типов HTTP-глаголов:
\begin{enumerate}[label=\arabic{enumi})]
	\item GET - для чтения(получения) ресурса. В случае удачи возвращает код состояния 200(OK) и представление запрашиваемого ресурса. Он является идемпотентным.
	\item POST - для создания новых ресурсов. В случае успеха возвращает HTTP код 201(CREATED) и в заголовке Location адрес созданного ресурса
	\item DELETE - для удаления ресурса с конкретным ID. В случае успеха возвращает код 200(OK) вместе с данными удаленного ресурса или код 204(NO CONTENT) без тела.
	\item PUT - для полного обновления ресурса. При успехе возвращается HTTP 200(OK)
	\item PATH - для частичной модификации ресурса, он содержит только изменяемые данные.
\end{enumerate}

Основные плюсы REST: 

\begin{itemize}
	\item надежность
	\item хорошая масштабируемость
	\item производительность
	\item отказоустойчивость
	\item простота поддержки
\end{itemize}

Для реализации функционала уведомлений была использована технология SSE(server-sent events). Она позволяет с легкостью передавать уведомления от сервера к клиенту. Клиент подписывается на события, которые будет отправлять сервер и как только происходит событие, клиент моментально получает уведомление. Мы выбрали именно эту технологию, а не подобные ей(WebSocket, Long Pooling и т.д.) потому, что SSE проще, поддерживает автоматическое переподключение в случае обрыва соединения, а так же для наших целей не нужно полноценное двунаправленное соединение, ведь данные от клиента к серверу мы передаем по HTTP. Клиент посылает запрос на сервер для открытия соединения, а сервер в ответ посылает заголовок 'Content-Type: text/event-stream' и с этого момента соединение считается открытым.

\section{Реализация серверной части}
\subsection{Архитектура серверной части}
Каждый модуль системы реализует компоненты: 
\begin{enumerate}[label=\arabic{enumi})]
	\item модель - описывает саму сущность модуля, например “Папка”. Это объектное представление сущности из базы данных
	\item репозиторий - слой доступа к данным в БД. По сути, это паттерн, который инкапсулирует в себе все, что относится к хранению данных. В нашем приложении он служит для того, чтобы отделить бизнес-логику от конкретной реализации поставщика базы данных, а так же для уменьшения связанности модулей приложения и предотвращения круговых зависимостей. Для того, чтобы избежать подключения всего модуля сущности для простого доступа к данным(например, CRUD - Create, Read, Update, Delete), можно подключить отдельно модуль с репозиторием. В таком случае бизнес логика будет недоступна
	\item сервис - описывает всю бизнес-логику, которая относится к конкретной модели. 
	\item контроллер - принимает входящие запросы, делегирует их сервису и возвращает ответ. Он выступает в роли промежуточного звена между клиентом и бизнес-логикой.
\end{enumerate}

На рис.~\ref{fig:4}. можно посмотреть схематичное представление архитектуры серверной части сервиса.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=1\textwidth]{img/archServ.jpg}
	\caption{Архитектура серверной части}
	\label{fig:4} % Метка для ссылки в тексте
\end{figure}

В ходе создания сервиса была спроектирована и создана база данных. Таблицы и их связи представлены ниже на рис.~\ref{fig:5}.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=1\textwidth]{img/dbDiagram.jpg}
	\caption{Диаграмма базы данных сервиса}
	\label{fig:5} % Метка для ссылки в тексте
\end{figure}


\subsection{Обзор технологий для написания серверной части}
В качестве языка программирования мы выбрали TypeScript. TypeScript - это компилируемый в JavaScript язык программирования.
Он позволяет писать строго типизированный код и следовать лучшим ООП практикам. Особенно хорошо, что в TypeScript есть интерфейсы, это сильно улучшает стиль программирования и предотвращает многие ошибки.


Для написания backend-части сервиса использовался Nest.js - это мощный и гибкий фреймворк для написания эффективного серверного кода. Он построен на Express.js - самом популярном решении для создания серверного кода для платформы Node.js. 

Node.js - это платформа написанная на C++ с открытым исходным кодом для работы с языком JavaScript. Она построена на движке Chrome V8 и позволяет писать серверный код для веб-приложений. В основе платформы — событийно-управляемая модель с неблокирующими операциями ввода-вывода, что делает ее эффективной и легкой.[3]

Использование фреймворков помогает нам писать меньше шаблонного кода и сосредоточиться на решении конкретных бизнес-задачах. Преимущества Nest.js:

\begin{enumerate}[label=\arabic{enumi})]
	\item обеспечивает заранее масштабируемую и чистую архитектуру, требует от программиста писать хороший код
	\item поддерживает множество инструментов “из коробки”
	\item присутствуют мощные инструменты командного интерфейса для быстрой разработки модулей
	\item хорошая реализация инъекции зависимостей(Dependency Injection) из коробки
	\item поддержка сообщества
\end{enumerate}

Создатели данного фреймворка вдохновлялись Angular и многие вещи написаны с использованием декораторов. Декораторы - это способ “оборачивания” функций, они позволяют модифицировать поведение классов. 

Для хранения данных в сервисе использовалась СУБД PostgreSQL. Данная СУБД имеет ряд приемуществ по сравнению с другими СУБД, например:
\begin{itemize}
	\item можно работать с БД неограниченного размера
	\item поддерживает индексы, триггеры, функции
	\item имеет в свое арсенале форматы JSON и ARRAY
\end{itemize}

Для связи базы данных и объектов в приложении использовалась технология ORM(Object-Relational Mapping - объектно-реляционное отображение) и ее конкретная реализация - Sequelize ORM. Использование ORM аргументировано тем, что такой способ позволяет не зависить от способа хранения объектов(и самой БД), с легкостью переключаться между SQL и noSQL БД. Так же, ORM сильно повышает эффективность разработки и позволяет оперировать объектами-сущностями в ООП стиле.

Для решения аутентификации, авторизации и контроля доступа использовался продукт Keycloak. Преимущества решения:

\begin{enumerate}[label=\arabic{enumi})]
	\item единый вход в приложение(SSO)
	\item LDAP/Active Directory интеграция и быстрый перенос пользователей
	\item хороший и документированный API
\end{enumerate}

Документация конечных точек API для серверной части задокументирована с помощью OpenAPI 3.0 Swagger. Данная технология позволяет не только интерактивно просматривать все эндпоинты приложения, но и отправлять запросы прямо из интерфейса Swagger. Вся документация к конечным точкам приложения находится по пути http://host:3000/api/docs и представляет собой документацию Swagger, пример на рис.~\ref{fig:6}.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=1\textwidth]{img/swagger.png}
	\caption{Пример документации конечных точек Swagger}
	\label{fig:6} % Метка для ссылки в тексте
\end{figure}

\section{Клиентская часть}

\subsection{Архитектура клиентской части}
Клиентская часть написана с использованием методологии атомарного дизайна. Она предполагает, что все приложение разделяется на атомы, молекулы, организмы, шаблоны и целые страницы. ??????????
-----TODO(написать про vuex тут больше и как состояние рабоатет)


\subsection{Обзор технологий для написания клиентской части}
Для клиентской части приложения использовался язык программирования JavaScript и фреймворк Vue.js 2. Для интерфейсов средней сложности это идеальный выбор, потому что данное решение легко масштабировать, у него прекрасная документация, а так же он очень производительный.

В роли менеджера состояния у нас выступает библиотека и одновременно паттерн управления состоянием Vuex 3. Это самое популярное решение для Vue, потому что данные хранятся с правилами, которые гарантируют изменение только предсказуемым образом. По мере роста приложения возникает потребность передавать данные между компонентами и это начинает приносить неудобства в использовании данных. Vuex призван решить эту проблему. В нем данные хранятся централизовано. На рис.~\ref{fig:7}. показано как происходит работа с данными.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=1\textwidth]{img/vuex.png}
	\caption{работа с данными во Vuex}
	\label{fig:7} % Метка для ссылки в тексте
\end{figure}

Управление маршрутами происходит с помощью Vue Router - официального роутера для Vue.js.

В качестве UI библиотеки для написания компонентов интерфейса мы использовали библиотеку Vuetify 2.6. Данное решение хорошо документировано и позволяет писать масштабируемые компоненты.

\section{Защита данных}

В приложении проводится безопасное сетевое взаимодействие между сервером и клиентом. Это означает, что данные о паролях не передаются в открытом виде по HTTP. В качестве алгоритма шифрования мы взяли RSA. Шаги по шифрованию паролей в сервисе: 

\begin{enumerate}[label=\arabic{enumi})]
	\item при аутентификации клиент генерирует приватный и публичный 1024-битные ключи
	\item клиент отправляет серверу публичный ключ
	\item сервер сохраняет публичный ключ от клиента в базе данных, генерирует пару: свой приватный ключ и свой публичный ключ и отправляет публичный ключ ответом на запрос клиенту
	\item пароли передаются в виде { message, signature }, здесь message - сообщение для шифрования, а signature - подпись
	\item для расшифровки отправленного с клиента пароля, сервер проверяет сообщение от клиента по подписи и сохраненному в БД публичному ключу
	\item для передачи с сервера на клиент зашифрованного пароля мы шифруем сообщение с помощью публичного ключа, генерируем подпись для зашифрованного сообщения с помощью приватного ключа
\end{enumerate}
Реализация данного алгоритма представлена в приложении А.

\chapternonum{Заключение}

В заключении подводятся итоги выполненной работы, рассказывается о~том, что удалось и~что не~удалось сделать, описываются перспективы продолжения исследований.

\textbf{Перспективы исследования.} В дальнейшем планируется создание дополнительного функционала, например создаение публичных паролей с разовыми токенами для авторизации, чтобы доступ в некоторым паролям имели не только сотрудники компании. Так же планируется улучшить эффективность серверной и клиентской части приложения, для этого будут использоваться специальные инструменты замера метрик скорости работы приложения.

% Если нужно, меняем название Литература
\renewcommand{\bibname}{Список литературы} 
\begin{thebibliography}{9}
% Если нужно сделать N. вместо [N] 
% \makeatletter\renewcommand{\@biblabel}[1]{#1.}\makeatother

\bibitem{TeX:YarSU}
	TeX в ЯрГУ [Электронный ресурс].
	URL: \url{http://www.tex.uniyar.ac.ru}
	(дата доступа: 20.05.2017).

\bibitem{Oetiker:2016}
	REST, что же ты такое?
	URL: \url{https://systems.education/what-is-rest}
	(дата доступа: 14.05.2022).

\bibitem{Kotelnikov:2004}
	Node.js
	URL: \url{https://blog.skillfactory.ru/glossary/node-js/}
	(дата доступа: 14.05.2022).


\bibitem{tikz}
	Tantau~T.
	PGF~--- Create PostScript and PDF graphics in {\TeX} [Электронный ресурс].
	URL: \url{https://www.ctan.org/pkg/pgf}
	(дата доступа: 17.05.2017).

\bibitem{Kirutenko:2014}
	Кирютенко~Ю.\,А.
	TikZ \& PGF. Создание графики в \LaTeXe-документах. Ростов-на-Дону, 2014. 277~c.
	URL: \url{https://open-edu.sfedu.ru/files/pgf-ru-all-method.pdf}

%\bibitem{TikzEdt}
%	TikzEdt. A semigraphical TikZ editor. [Электронный ресурс]. 2013. URL: \url{http://www.tikzedt.org/

\bibitem{Cook:1971}
	\selectlanguage{english}
	Cook~S.\,A. 
	The complexity of theorem-proving procedures
	//~Proceedings of the third annual ACM symposium on Theory of computing. 
	ACM, 1971. P.~151--158.
	\selectlanguage{russian}

\bibitem{Pupyrev:2010}
	Пупырев~С.\,Н., Тихонов~А.\,В.
	Визуализация динамических графов для анализа сложных сетей
	//~Модел. и анализ информ. систем. 
	2010. Т.~17, №~1. С.~117--135.

\bibitem{Kuzmin:2000}
	Кузьмин~И.\,Г. 
	Некоторые проблемы государственных финансов в современной России
	//~Российские предприятия в системе рыночных отношений\,: материалы научно"=практич. конф. Ярославль, 17--18~окт. 2000~г. /~отв.~ред. Л.Б.~Парфенова.  Ярославль, 2000.  С.~86--90.
	
\bibitem{GOST-2001}
	ГОСТ Р~517721-2001.
	Аппаратура радиоэлектронная бытовая. Входные и выходные параметры и типы соединений. Технические требования.  Введ. 2002-01-01. М.\,: Изд"~во стандартов, 2001. IV, 27~с.
	
\end{thebibliography}


% Приложения
\appendix
	
% Настраиваем общее для всех языков оформление листинга
\lstset{
	%	breaklines=true,
	%	frame=l,
	%	showstringspaces=false,
	tabsize=4, % длина табуляции в пробелах
	formfeed=\newpage, % реакция на символ "form feed"
	extendedchars=true, % используем неанглийские буквы
	basicstyle=\ttfamily, % базовый стиль
%	keywordstyle=\bfseries, % стиль ключевых слов (попробуйте \pmb если \bfseries не работает)
	commentstyle=\rmfamily\itshape, % стиль для комментариев
	stringstyle=\slshape, % стиль строк в кавычках
	numbers=left, % где проставляем номера строк; возможные значения: none, left, right
	numbersep=1em, % расстояние (по горизонтали) от номеров строк до кода
	stepnumber=1, % шаг отображения номеров строк. Если 1, то каждая строка помечается номером
	numberstyle=\footnotesize\color{black}, % стиль для номеров строк
}

\chapter{Исходный код класса защиты данных на TypeScript}
\label{app:source}


\lstdefinestyle{TypeScript}{
	language=TypeScript,
}

% Загружаем код из файла
\lstinputlisting{crypt.ts} 

\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%
% Конец документа
%%%%%%%%%%%%%%%%%%%%%%%%%%
